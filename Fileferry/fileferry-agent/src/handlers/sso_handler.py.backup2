"""
SSO Authentication Handler
Handles AWS SSO authentication with session management and auto-logout
"""

import boto3
import asyncio
from botocore.exceptions import ClientError, NoCredentialsError
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
from aws_xray_sdk.core import xray_recorder

from ..utils.logger import get_logger

logger = get_logger(__name__)


class SSOHandler:
    """
    Handles AWS SSO authentication with automatic session management
    Implements 10-second auto-logout for security compliance
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize SSO handler
        
        Args:
            config: Configuration containing:
                - sso_start_url: AWS SSO start URL
                - sso_region: AWS SSO region
                - account_id: AWS account ID
                - role_name: IAM role name for SSO
                - session_duration: Session duration in seconds (default: 10)
                - test_mode: Bypass SSO authentication (default: False)
        """
        # SSO configuration
        sso_config = config.get('sso', {})
        self.sso_start_url = sso_config.get('start_url')
        self.sso_region = sso_config.get('region', 'us-east-1')
        self.account_id = sso_config.get('account_id')
        self.role_name = sso_config.get('role_name', 'FileFerryReadOnlyRole')
        self.session_duration = sso_config.get('session_duration', 10)  # 10 seconds
        
        # Test mode from agent config
        agent_config = config.get('agent', {})
        self.test_mode = agent_config.get('test_mode', False)  # Test mode flag
        
        # Active sessions tracking
        self.active_sessions: Dict[str, Dict] = {}
        
        if self.test_mode:
            logger.warning("âš ï¸ SSO Handler in TEST MODE - using default AWS credentials")
        else:
            logger.info("âœ… SSO Handler initialized")
    
    @xray_recorder.capture('sso_authenticate')
    async def authenticate(self, region: str = None) -> Dict[str, Any]:
        """
        Authenticate with AWS SSO and establish a temporary session
        
        Args:
            region: AWS region for the session
            
        Returns:
            Dictionary containing session credentials and metadata
        """
        # Test mode: Use default AWS credentials without SSO
        if self.test_mode:
            logger.info("ðŸ§ª Test mode: Using default AWS credentials (no SSO)")
            session_data = {
                'session_id': f"test_session_{int(datetime.utcnow().timestamp() * 1000)}",
                'test_mode': True,
                'authenticated_at': datetime.utcnow(),
                'region': region or self.sso_region,
                'account_id': self.account_id or 'test'
            }
            self.active_sessions[session_data['session_id']] = session_data
            logger.info(f"âœ… Test mode session created: {session_data['session_id']}")
            return session_data
        
        try:
            logger.info(f"Authenticating with AWS SSO for account {self.account_id}")
            
            # Create STS client
            sts_client = boto3.client('sts', region_name=region or self.sso_region)
            
            # Assume role with read-only policy
            role_arn = f"arn:aws:iam::{self.account_id}:role/{self.role_name}"
            
            response = sts_client.assume_role(
                RoleArn=role_arn,
                RoleSessionName=f"FileFerry-{int(datetime.utcnow().timestamp())}",
                DurationSeconds=3600  # 1 hour max, but we'll enforce 10-second logout
            )
            
            credentials = response['Credentials']
            
            session_data = {
                'session_id': f"session_{int(datetime.utcnow().timestamp() * 1000)}",
                'access_key_id': credentials['AccessKeyId'],
                'secret_access_key': credentials['SecretAccessKey'],
                'session_token': credentials['SessionToken'],
                'expiration': credentials['Expiration'],
                'authenticated_at': datetime.utcnow(),
                'region': region or self.sso_region,
                'account_id': self.account_id,
                'role_arn': role_arn
            }
            
            # Store active session
            self.active_sessions[session_data['session_id']] = session_data
            
            # Schedule auto-logout after 10 seconds
            asyncio.create_task(
                self.auto_logout_after_delay(session_data, self.session_duration)
            )
            
            logger.info(f"âœ… SSO authentication successful. Session: {session_data['session_id']}")
            logger.info(f"â° Auto-logout scheduled in {self.session_duration} seconds")
            
            return session_data
            
        except NoCredentialsError:
            logger.error("âŒ No AWS credentials found")
            raise SSOAuthenticationError("No AWS credentials configured")
            
        except ClientError as e:
            error_code = e.response['Error']['Code']
            error_message = e.response['Error']['Message']
            logger.error(f"âŒ AWS STS error ({error_code}): {error_message}")
            
            if error_code == 'AccessDenied':
                raise SSOAuthenticationError(f"Access denied to role {self.role_name}")
            else:
                raise SSOAuthenticationError(f"AWS STS error: {error_message}")
                
        except Exception as e:
            logger.error(f"âŒ Unexpected SSO authentication error: {str(e)}", exc_info=True)
            raise SSOAuthenticationError(f"Authentication failed: {str(e)}")
    
    @xray_recorder.capture('sso_logout')
    async def logout(self, session_data: Dict[str, Any]) -> None:
        """
        Logout and invalidate session credentials
        
        Args:
            session_data: Session data from authenticate()
        """
        session_id = session_data.get('session_id')
        
        if session_id in self.active_sessions:
            del self.active_sessions[session_id]
            logger.info(f"ðŸ”’ Session {session_id} logged out successfully")
        else:
            logger.warning(f"âš ï¸ Attempted to logout non-existent session: {session_id}")
    
    async def auto_logout_after_delay(self, session_data: Dict[str, Any], delay_seconds: int = None) -> None:
        """
        Automatically logout after specified delay (default: 10 seconds)
        
        Args:
            session_data: Session data
            delay_seconds: Delay before auto-logout
        """
        delay = delay_seconds or self.session_duration
        session_id = session_data.get('session_id')
        
        logger.info(f"â° Auto-logout scheduled for session {session_id} in {delay} seconds")
        
        await asyncio.sleep(delay)
        
        await self.logout(session_data)
        logger.info(f"âœ… Auto-logout completed for session {session_id}")
    
    def get_boto3_session(self, session_data: Dict[str, Any]) -> boto3.Session:
        """
        Create boto3 Session from SSO credentials
        
        Args:
            session_data: Session data from authenticate()
            
        Returns:
            Configured boto3.Session
        """
        # Test mode: Return default boto3 session
        if session_data.get('test_mode'):
            logger.info("ðŸ§ª Test mode: Using default boto3 session")
            return boto3.Session(region_name=session_data.get('region', self.sso_region))
        
        return boto3.Session(
            aws_access_key_id=session_data['access_key_id'],
            aws_secret_access_key=session_data['secret_access_key'],
            aws_session_token=session_data['session_token'],
            region_name=session_data.get('region', self.sso_region)
        )
    
    def is_session_valid(self, session_data: Dict[str, Any]) -> bool:
        """
        Check if session is still valid (not expired)
        
        Args:
            session_data: Session data
            
        Returns:
            True if valid, False otherwise
        """
        session_id = session_data.get('session_id')
        
        if session_id not in self.active_sessions:
            logger.warning(f"Session {session_id} not found in active sessions")
            return False
        
        expiration = session_data.get('expiration')
        if isinstance(expiration, str):
            expiration = datetime.fromisoformat(expiration.replace('Z', '+00:00'))
        
        is_valid = datetime.utcnow() < expiration.replace(tzinfo=None)
        
        if not is_valid:
            logger.warning(f"Session {session_id} has expired")
        
        return is_valid
    
    async def refresh_session_if_needed(self, session_data: Dict[str, Any], region: str = None) -> Dict[str, Any]:
        """
        Refresh session if it's expired or about to expire
        
        Args:
            session_data: Existing session data
            region: AWS region
            
        Returns:
            Refreshed or existing session data
        """
        if not self.is_session_valid(session_data):
            logger.info("Session expired, re-authenticating...")
            return await self.authenticate(region)
        
        return session_data
    
    def get_session_info(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get session information (without sensitive credentials)
        
        Args:
            session_data: Session data
            
        Returns:
            Safe session information
        """
        return {
            'session_id': session_data.get('session_id'),
            'authenticated_at': session_data.get('authenticated_at').isoformat() if session_data.get('authenticated_at') else None,
            'expiration': session_data.get('expiration').isoformat() if isinstance(session_data.get('expiration'), datetime) else session_data.get('expiration'),
            'region': session_data.get('region'),
            'account_id': session_data.get('account_id'),
            'role_arn': session_data.get('role_arn'),
            'valid': self.is_session_valid(session_data)
        }


class SSOAuthenticationError(Exception):
    """Custom exception for SSO authentication errors"""
    pass